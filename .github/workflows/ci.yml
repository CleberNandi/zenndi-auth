name: CI/CD - Build, Test, and Deploy

on:
  push:
    branches:
      - "feature/**"
      - "dev"
      - "hml"
      - "main"
  pull_request:
    branches:
      - "dev"
      - "hml"
      - "main"

  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  check-branch-push:
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - name: Block direct pushes to protected branches
        run: |
          PROTECTED_BRANCHES=("refs/heads/dev" "refs/heads/hml" "refs/heads/main")
          if [[ " ${PROTECTED_BRANCHES[@]} " =~ " ${GITHUB_REF} " ]]; then
            echo "‚ùå Direct pushes to '${GITHUB_REF#refs/heads/}' are not allowed."
            echo "Please use a feature branch and open a Pull Request."
            exit 1
          fi
          echo "‚úÖ Push is to a feature branch. Proceeding..."

  test:
    runs-on: ubuntu-latest
    needs: check-branch-push
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file for CI
        env:
          # Define as vari√°veis de ambiente de forma segura.
          # Se o segredo existir, ele ser√° usado. Caso contr√°rio, o script 'run' usar√° um valor padr√£o.
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        run: |
          echo "Creating .env file for testing..."
          cat <<EOF > .env
          # CI Environment Variables
          POSTGRES_USER=${POSTGRES_USER}
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          POSTGRES_DB=${POSTGRES_DB}
          DATABASE_URL="postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}"
          REDIS_URL="redis://redis:6379/0"
          ENV_MODE=test

          # Dummy secrets for testing
          SECRET_KEY=a-very-secret-key-for-ci-that-is-not-production
          ALGORITHM=HS256
          SMTP_USER=test@example.com
          SMTP_PASSWORD=password
          SMTP_SERVER=mail.example.com
          SMTP_PORT=587
          EOF

      - name: Start services (DB + Redis) for CI
        run: docker compose -f docker-compose.ci.yml up -d db redis

      - name: Wait for services to be healthy
        run: |
          echo "Waiting for DB and Redis to be healthy..."
          docker compose -f docker-compose.ci.yml ps
          for i in $(seq 1 12); do
            DB_STATUS=$(docker inspect -f '{{.State.Health.Status}}' $(docker compose -f docker-compose.ci.yml ps -q db))
            REDIS_STATUS=$(docker inspect -f '{{.State.Health.Status}}' $(docker compose -f docker-compose.ci.yml ps -q redis))
            if [ "$DB_STATUS" = "healthy" ] && [ "$REDIS_STATUS" = "healthy" ]; then
              echo "‚úÖ All services are healthy!"
              break
            fi
            echo "Services not ready yet... waiting 5s (DB: $DB_STATUS, Redis: $REDIS_STATUS)"
            sleep 5
          done
          if [ "$DB_STATUS" != "healthy" ] || [ "$REDIS_STATUS" != "healthy" ]; then
            echo "‚ùå Services did not become healthy after 60 seconds"
            docker compose -f docker-compose.ci.yml logs
            exit 1
          fi

      - name: Build API image for testing
        # Este passo garante que a imagem 'api' seja constru√≠da com o c√≥digo mais recente
        run: docker compose -f docker-compose.ci.yml build api

      - name: Run Alembic migrations
        run: |
          echo "üöÄ Applying database migrations..."
          docker compose -f docker-compose.ci.yml run --rm api uv run alembic upgrade head

      - name: Run tests
        run: |
          echo "üß™ Running tests with pytest..."
          # Executa o pytest e permite que ele falhe.
          # Em seguida, verifica o c√≥digo de sa√≠da. Se for 5 (nenhum teste encontrado),
          # o passo √© considerado um sucesso. Qualquer outro c√≥digo de erro resultar√° em falha.
          docker compose -f docker-compose.ci.yml run --rm api uv run pytest || \
            (test $? -eq 5 && echo "‚úÖ Pytest passou sem encontrar testes." || exit $?)

      - name: Tear down services
        if: always()
        run: |
          echo "üßπ Cleaning up CI environment..."
          docker compose -f docker-compose.ci.yml down -v --remove-orphans

  create-pr:
    runs-on: ubuntu-latest
    needs: test
    if: success() && startsWith(github.ref, 'refs/heads/feature/')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract feature branch info
        shell: bash
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          FEATURE_NAME=${BRANCH_NAME#feature/}
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "FEATURE_NAME=$FEATURE_NAME" >> $GITHUB_ENV

      - name: Check if PR already exists
        id: check-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${process.env.BRANCH_NAME}`,
              base: 'dev',
              state: 'open'
            });
            if (pulls.length > 0) {
              core.setOutput('exists', 'true');
              console.log(`PR already exists: #${pulls[0].number}`);
            } else {
              core.setOutput('exists', 'false');
            }

      - name: Create Pull Request
        if: steps.check-pr.outputs.exists == 'false'
        uses: repo-sync/pull-request@v2
        with:
          source_branch: ${{ env.BRANCH_NAME }}
          destination_branch: "dev"
          pr_title: "‚ú® Feature: ${{ env.FEATURE_NAME }}"
          pr_body: |
            ## üöÄ Auto PR - Feature Branch
            **Branch**: `${{ env.BRANCH_NAME }}`
            **Testes**: ‚úÖ Passaram com sucesso no workflow #${{ github.run_number }}
            ---
            *Esta PR foi criada automaticamente.*
          github_token: ${{ secrets.PAT }}


  build-and-push:
    runs-on: ubuntu-latest
    needs: test
    # S√≥ executa em pushes para os branches principais, n√£o em PRs
    if: success() && github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/hml' || github.ref == 'refs/heads/dev')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract branch name
        shell: bash
        run: |
          BRANCH=${GITHUB_REF#refs/heads/}
          echo "BRANCH_NAME=$BRANCH" >> $GITHUB_ENV

      - name: Generate Docker tags
        id: meta
        run: |
          REPO="clebernandi/zenndi-auth"
          BRANCH="${{ env.BRANCH_NAME }}"
          TAGS=""

          if [ "$BRANCH" == "main" ]; then
            TAGS="$REPO:latest,$REPO:${{ github.run_number }}"
          else
            TAGS="$REPO:$BRANCH"
          fi

          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è Generated tags: $TAGS"

      - name: Build and push production image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./build/deployments/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
